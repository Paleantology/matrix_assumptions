# Set up branch length hyperprior with a move
br_len_lambda ~ dnExp(0.2)
moves.append( mvScale(br_len_lambda, weight=2) )

# Define the tree parameter.
# First, we generate the topology.
# We assume a uniform prior on topology.
phylogeny ~ dnUniformTopologyBranchLength(taxa, branchLengthDistribution=dnExponential(br_len_lambda))

# compute the tree length from the phylogeny
tree_length := phylogeny.treeLength()

moves.append( mvNNI(phylogeny, weight=num_branches/2.0) )
moves.append( mvSPR(phylogeny, weight=num_branches/10.0) )
moves.append( mvBranchLengthScale(phylogeny, weight=num_branches) )


# Set up Gamma-distributed rate variation.
alpha_morpho ~ dnUniform( 0.0, 1E6 )
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

# Moves on the parameters to the Gamma distribution.
moves.append( mvScale(alpha_morpho, lambda=1, weight=2.0) )

n_max_states <- 7
idx = 1




morpho_bystate[1] <- morpho
for (i in 2:n_max_states) {
    morpho_bystate[i] <- morpho                                # make local tmp copy of data
    morpho_bystate[i].setNumStatesPartition(i)                 # only keep character blocks with state space equal to size i
    nc = morpho_bystate[i].nchar() # get number of characters per character size with i-sized states
    # Specify the two parameters to the Beta distribution, and the moves on these parameters.
    beta_scale ~ dnLognormal( 0.0, sd=2*0.587405 )
    moves.append( mvScale(beta_scale, lambda=1, weight=5.0 ) )
    beta_scale
    if (nc > 0) {
      i
      for (j in 1:i)
      {
        Q[idx][j] := fnF81(simplex(fnDiscretizeBeta(beta_scale, beta_scale, i)))
        Q[idx][j]
      } # make i-by-i rate matrix

      # Tell the model what the probability of a character going into any particular category.
      # This prior says that a character is equally likely to be put into any category.
      mat_prior[idx] <- rep(1, i)
      matrix_probs[idx] ~ dnDirichlet(mat_prior[idx])

      moves.append( mvBetaSimplex(matrix_probs[idx], weight=3.0) )
      moves.append( mvDirichletSimplex(matrix_probs[idx], weight=1.5) )

      m_morph[idx] ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho,
                              Q=Q[idx], type="Standard",
                              siteMatrices=matrix_probs[idx])
      m_morph[idx].clamp(morpho_bystate[i])

      idx = idx + 1                                          # increment counter
      idx
    }
}
